clear all
clc
close all

%Распознавание работает в три этапа.
%1. Выделение областей для распознавания
%2. Сегментация в выделенных областях. На данном этапе нужно 
%   выделить "цифроподобные" области, которые потом будут 
%   сравниваться с "идеалами" (примерами) цифр
%3. Сравнение сегментированных областей с примерами.


img = imread('1.jpg');
[m n k] = size(img);
imshow(img)

%allocation of needed area
%c = getrect
c = [1738 222 440 1212];
img2 = img(c(2):c(2)+c(4), c(1):c(1)+c(3), :);
%imshow(img2);

%to show edges
BW = edge(img2(:,:,1),'log');
%figure(1)
%imshow(BW)

index_y = windows_9(BW);%выделение 9 окошек по y
plot_int(BW,index_y);% рисование 9 выделенных окошек на одной фигуре. 
%Вспомогательная функция
hold off

%У-координата найдена. Надо теперь найти х-координату.
%(ПРОЦЕСС СЕГМЕНТАЦИИ)
%я зафиксировала эти два индеса для простоты проверки 
%написанных методов. Как только методы будут написаны правильно,
%тут ставится цикл и все проверяется автоматически для всех 9 черных
%областей
ind1 = 16;
ind2 = 17;
%благодаря вышеописанным зафиксированным индексом, я выделяю всего ОДНУ
%черную область img_2
img_2 = BW(index_y(ind1):index_y(ind2),:,:);%по у
index_x = numbers(img_2);%метод находит все индексы по х.
%Метод сегментирует области. Надо определить теперь где цифра, 
%а где мусор
index_y_n = [index_y(ind1) index_y(ind2)];%опять: массив для определения черной области
y = detection3(BW,index_x,index_y_n)%метод распознает цифры



%теперь хочу взять все эти кусочки и начать сравнивать с оригиналом в
%нейронной сети. Если нет ничего подобного, то тогда прога ничего не выдает






    
    
